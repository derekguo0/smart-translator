<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AIæ™ºèƒ½å›¾æ–‡ç¿»è¯‘åŠ©æ‰‹ - å…è´¹åœ¨çº¿OCRè¯†åˆ«å’Œå¤šè¯­è¨€ç¿»è¯‘å·¥å…·ï¼Œæ”¯æŒå›¾ç‰‡æ–‡å­—è¯†åˆ«ã€ChatGPTç¿»è¯‘ã€Googleç¿»è¯‘">
    <meta name="keywords" content="ç¿»è¯‘å·¥å…·,OCRè¯†åˆ«,å›¾ç‰‡ç¿»è¯‘,åœ¨çº¿ç¿»è¯‘,ChatGPTç¿»è¯‘,Googleç¿»è¯‘,å¤šè¯­è¨€ç¿»è¯‘">
    <meta name="author" content="AIæ™ºèƒ½ç¿»è¯‘åŠ©æ‰‹">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://your-username.github.io/translate-tool/">
    <meta property="og:title" content="AIæ™ºèƒ½å›¾æ–‡ç¿»è¯‘åŠ©æ‰‹ - å…è´¹åœ¨çº¿ç¿»è¯‘å·¥å…·">
    <meta property="og:description" content="ä¸€é”®å®Œæˆå›¾ç‰‡æ–‡å­—è¯†åˆ«å’Œå¤šè¯­è¨€ç¿»è¯‘ï¼Œæ”¯æŒChatGPTé«˜è´¨é‡ç¿»è¯‘å’ŒGoogleå…è´¹ç¿»è¯‘">
    <meta property="og:image" content="https://your-username.github.io/translate-tool/preview.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://your-username.github.io/translate-tool/">
    <meta property="twitter:title" content="AIæ™ºèƒ½å›¾æ–‡ç¿»è¯‘åŠ©æ‰‹">
    <meta property="twitter:description" content="ä¸€é”®å®Œæˆå›¾ç‰‡æ–‡å­—è¯†åˆ«å’Œå¤šè¯­è¨€ç¿»è¯‘ï¼Œæ”¯æŒChatGPTé«˜è´¨é‡ç¿»è¯‘å’ŒGoogleå…è´¹ç¿»è¯‘">
    <meta property="twitter:image" content="https://your-username.github.io/translate-tool/preview.png">
    
    <title>AIæ™ºèƒ½å›¾æ–‡ç¿»è¯‘åŠ©æ‰‹ - å…è´¹OCRè¯†åˆ«å’Œå¤šè¯­è¨€ç¿»è¯‘å·¥å…·</title>
    
    <!-- Google Analytics (æ›¿æ¢ä¸ºæ‚¨è‡ªå·±çš„GA ID) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'GA_MEASUREMENT_ID');
    </script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Tesseract.js for OCR - Multiple CDN sources for reliability -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js" 
            onerror="this.onerror=null; this.src='https://unpkg.com/tesseract.js@5/dist/tesseract.min.js';"
            onload="console.log('Tesseract.js loaded successfully')">
    </script>
    
    <!-- Custom Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#2563eb',
                        'primary-dark': '#1d4ed8',
                        'secondary': '#64748b',
                        'success': '#10b981',
                        'error': '#ef4444',
                        'warning': '#f59e0b',
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Custom animations */
        @keyframes pulse-soft {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .animate-pulse-soft {
            animation: pulse-soft 2s ease-in-out infinite;
        }
        
        /* Drag and drop styles */
        .drag-over {
            background-color: #dbeafe;
            border-color: #3b82f6;
        }
        
        /* Custom scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        /* Progress bar styles */
        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-bar-fill {
            height: 100%;
            background-color: #f59e0b;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Navigation Bar -->
    <nav class="bg-white shadow-lg border-b border-gray-200">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <!-- Logo -->
                <div class="flex items-center">
                    <div class="flex-shrink-0 flex items-center">
                        <i class="fas fa-language text-primary text-2xl mr-3"></i>
                        <h1 class="text-xl font-bold text-gray-900">AIç¿»è¯‘åŠ©æ‰‹</h1>
                    </div>
                </div>
                
                <!-- Language Selection -->
                <div class="flex items-center space-x-4">
                    <!-- Translation Service Selector -->
                    <div class="relative">
                        <select id="translationService" class="appearance-none bg-white border border-gray-300 rounded-lg px-3 py-2 pr-8 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent text-sm">
                            <option value="google">Google ç¿»è¯‘</option>
                            <option value="chatgpt">ChatGPT (é«˜è´¨é‡)</option>
                        </select>
                        <i class="fas fa-chevron-down absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 pointer-events-none"></i>
                    </div>
                    
                    <!-- API Key Setting Button -->
                    <button id="apiKeyBtn" class="p-2 text-gray-500 hover:text-primary transition-colors" title="APIå¯†é’¥è®¾ç½®">
                        <i class="fas fa-key"></i>
                    </button>
                    
                    <div class="relative">
                        <select id="sourceLanguage" class="appearance-none bg-white border border-gray-300 rounded-lg px-4 py-2 pr-8 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            <option value="auto">è‡ªåŠ¨æ£€æµ‹</option>
                            <option value="zh-CN">ä¸­æ–‡</option>
                            <option value="en">English</option>
                            <option value="ja">æ—¥è¯­</option>
                            <option value="ko">éŸ©è¯­</option>
                            <option value="es">è¥¿ç­ç‰™è¯­</option>
                            <option value="fr">æ³•è¯­</option>
                            <option value="de">å¾·è¯­</option>
                            <option value="ru">ä¿„è¯­</option>
                        </select>
                        <i class="fas fa-chevron-down absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 pointer-events-none"></i>
                    </div>
                    
                    <button id="swapLanguages" class="p-2 text-gray-500 hover:text-primary transition-colors">
                        <i class="fas fa-exchange-alt"></i>
                    </button>
                    
                    <div class="relative">
                        <select id="targetLanguage" class="appearance-none bg-white border border-gray-300 rounded-lg px-4 py-2 pr-8 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            <option value="en">English</option>
                            <option value="zh-CN">ä¸­æ–‡</option>
                            <option value="ja">æ—¥è¯­</option>
                            <option value="ko">éŸ©è¯­</option>
                            <option value="es">è¥¿ç­ç‰™è¯­</option>
                            <option value="fr">æ³•è¯­</option>
                            <option value="de">å¾·è¯­</option>
                            <option value="ru">ä¿„è¯­</option>
                        </select>
                        <i class="fas fa-chevron-down absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 pointer-events-none"></i>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Input Section -->
            <div class="space-y-6">
                <!-- Text Input -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold text-gray-900 flex items-center">
                            <i class="fas fa-keyboard text-primary mr-2"></i>
                            æ–‡æœ¬ç¿»è¯‘
                        </h2>
                        <button id="clearTextInput" class="text-gray-400 hover:text-error transition-colors">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    
                    <div class="relative">
                        <textarea 
                            id="textInput" 
                            placeholder="è¾“å…¥è¦ç¿»è¯‘çš„æ–‡æœ¬ï¼Œæˆ–ä¸Šä¼ å›¾ç‰‡åç›´æ¥ç‚¹å‡»ç¿»è¯‘æŒ‰é’®è¿›è¡ŒOCR+ç¿»è¯‘..."
                            class="w-full h-32 p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent resize-none custom-scrollbar"
                            maxlength="5000"
                        ></textarea>
                        <div class="absolute bottom-2 right-2 text-xs text-gray-400">
                            <span id="charCount">0</span>/5000
                        </div>
                    </div>
                </div>
                
                <!-- Image Upload Section -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold text-gray-900 flex items-center">
                            <i class="fas fa-image text-primary mr-2"></i>
                            å›¾ç‰‡ç¿»è¯‘
                        </h2>
                        <div class="flex items-center space-x-2">
                            <!-- OCR Engine Status Indicator -->
                            <div id="ocrStatusIndicator" class="flex items-center px-2 py-1 rounded-lg text-xs">
                                <i id="ocrStatusIcon" class="fas fa-circle text-yellow-500 mr-1"></i>
                                <span id="ocrStatusText">åˆå§‹åŒ–ä¸­</span>
                            </div>
                            
                            <!-- OCR Language Selection -->
                            <select id="ocrLanguage" class="appearance-none bg-gray-50 border border-gray-300 rounded-lg px-3 py-1 pr-6 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                                <option value="chi_sim+eng">ä¸­è‹±æ–‡</option>
                                <option value="chi_sim">ä¸­æ–‡ç®€ä½“</option>
                                <option value="chi_tra">ä¸­æ–‡ç¹ä½“</option>
                                <option value="eng">English</option>
                                <option value="jpn">æ—¥è¯­</option>
                                <option value="kor">éŸ©è¯­</option>
                                <option value="spa">è¥¿ç­ç‰™è¯­</option>
                                <option value="fra">æ³•è¯­</option>
                                <option value="deu">å¾·è¯­</option>
                                <option value="rus">ä¿„è¯­</option>
                            </select>
                            <i class="fas fa-chevron-down absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 pointer-events-none"></i>
                            <button id="clearImageInput" class="text-gray-400 hover:text-error transition-colors ml-2">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Drag and Drop Zone -->
                    <div id="dropZone" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-primary transition-colors cursor-pointer">
                        <div id="uploadPlaceholder" class="space-y-4">
                            <i class="fas fa-cloud-upload-alt text-4xl text-gray-400"></i>
                            <div>
                                <p class="text-lg text-gray-600">æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œ</p>
                                <p class="text-sm text-gray-500">æˆ–è€…ç‚¹å‡»ä¸Šä¼ ï¼Œæ”¯æŒ Ctrl+V ç²˜è´´</p>
                                <p class="text-xs text-primary mt-2">ğŸ’¡ ä¸Šä¼ å›¾ç‰‡åç›´æ¥ç‚¹å‡»ç¿»è¯‘æŒ‰é’®å³å¯è‡ªåŠ¨è¯†åˆ«+ç¿»è¯‘</p>
                            </div>
                            <div class="flex justify-center space-x-2">
                                <span class="inline-block bg-gray-100 text-gray-600 px-3 py-1 rounded-full text-xs">JPG</span>
                                <span class="inline-block bg-gray-100 text-gray-600 px-3 py-1 rounded-full text-xs">PNG</span>
                                <span class="inline-block bg-gray-100 text-gray-600 px-3 py-1 rounded-full text-xs">WEBP</span>
                                <span class="inline-block bg-gray-100 text-gray-600 px-3 py-1 rounded-full text-xs">GIF</span>
                            </div>
                        </div>
                        
                        <!-- Image Preview -->
                        <div id="imagePreview" class="hidden">
                            <img id="previewImage" class="max-w-full max-h-64 mx-auto rounded-lg shadow-md" alt="é¢„è§ˆå›¾ç‰‡">
                            <p class="text-sm text-gray-500 mt-2">ç‚¹å‡»é‡æ–°é€‰æ‹©å›¾ç‰‡</p>
                            <p class="text-xs text-primary mt-1">ğŸ’¡ å¯ç›´æ¥ç‚¹å‡»ç¿»è¯‘æŒ‰é’®è¿›è¡ŒOCRè¯†åˆ«+ç¿»è¯‘</p>
                        </div>
                    </div>
                    
                    <!-- Hidden File Input -->
                    <input type="file" id="imageInput" accept="image/*" class="hidden">
                </div>
                
                <!-- Action Buttons -->
                <div>
                    <button id="translateBtn" class="w-full bg-primary hover:bg-primary-dark text-white font-semibold py-3 px-6 rounded-lg transition-colors flex items-center justify-center space-x-2">
                        <i class="fas fa-language"></i>
                        <span>å¼€å§‹ç¿»è¯‘</span>
                    </button>
                </div>
            </div>
            
            <!-- Output Section -->
            <div class="space-y-6">
                <!-- Translation Result -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold text-gray-900 flex items-center">
                            <i class="fas fa-file-alt text-success mr-2"></i>
                            ç¿»è¯‘ç»“æœ
                        </h2>
                        <div class="flex space-x-2">
                            <button id="copyResult" class="text-gray-400 hover:text-success transition-colors" title="å¤åˆ¶ç¿»è¯‘ç»“æœ">
                                <i class="fas fa-copy"></i>
                            </button>
                            <button id="clearResult" class="text-gray-400 hover:text-error transition-colors" title="æ¸…ç©ºç»“æœ">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="relative">
                        <textarea 
                            id="translationResult" 
                            placeholder="ç¿»è¯‘ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."
                            class="w-full h-32 p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-success focus:border-transparent resize-none custom-scrollbar"
                            readonly
                        ></textarea>
                        
                        <!-- Loading Spinner -->
                        <div id="loadingSpinner" class="hidden absolute inset-0 flex items-center justify-center bg-white bg-opacity-75 rounded-lg">
                            <div class="flex items-center space-x-2">
                                <div class="animate-spin rounded-full h-6 w-6 border-2 border-primary border-t-transparent"></div>
                                <span class="text-primary font-medium">ç¿»è¯‘ä¸­...</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- OCR Result -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold text-gray-900 flex items-center">
                            <i class="fas fa-search text-warning mr-2"></i>
                            OCRè¯†åˆ«ç»“æœ
                        </h2>
                        <div class="flex space-x-2">
                            <button id="copyOCR" class="text-gray-400 hover:text-success transition-colors" title="å¤åˆ¶OCRç»“æœ">
                                <i class="fas fa-copy"></i>
                            </button>
                            <button id="clearOCR" class="text-gray-400 hover:text-error transition-colors" title="æ¸…ç©ºOCRç»“æœ">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="relative">
                        <textarea 
                            id="ocrResult" 
                            placeholder="OCRè¯†åˆ«ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."
                            class="w-full h-32 p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-warning focus:border-transparent resize-none custom-scrollbar"
                        ></textarea>
                        
                        <!-- OCR Loading Spinner with Progress -->
                        <div id="ocrLoadingSpinner" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-white bg-opacity-90 rounded-lg">
                            <div class="flex items-center space-x-2 mb-3">
                                <div class="animate-spin rounded-full h-6 w-6 border-2 border-warning border-t-transparent"></div>
                                <span class="text-warning font-medium">OCRè¯†åˆ«ä¸­...</span>
                            </div>
                            <div class="w-48 progress-bar">
                                <div id="ocrProgress" class="progress-bar-fill" style="width: 0%"></div>
                            </div>
                            <div class="text-xs text-gray-500 mt-2">
                                <span id="ocrStatus">æ­£åœ¨åˆå§‹åŒ–...</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Translation History (Optional) -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold text-gray-900 flex items-center">
                            <i class="fas fa-history text-purple-500 mr-2"></i>
                            ç¿»è¯‘å†å²
                        </h2>
                        <button id="clearHistory" class="text-gray-400 hover:text-error transition-colors" title="æ¸…ç©ºå†å²">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                    
                    <div id="historyList" class="space-y-2 max-h-48 overflow-y-auto custom-scrollbar">
                        <div class="text-gray-500 text-sm text-center py-4">
                            æš‚æ— ç¿»è¯‘å†å²
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Toast Notification Container -->
    <div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-2">
        <!-- Toast notifications will be inserted here -->
    </div>

    <!-- API Key Setting Modal -->
    <div id="apiKeyModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md mx-4">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold text-gray-900 flex items-center">
                    <i class="fas fa-key text-primary mr-2"></i>
                    APIå¯†é’¥è®¾ç½®
                </h3>
                <button id="closeApiKeyModal" class="text-gray-400 hover:text-gray-600">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                        OpenAI APIå¯†é’¥ (ChatGPT)
                    </label>
                    <input type="password" id="openaiApiKey" 
                           placeholder="sk-..." 
                           class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                    <p class="text-xs text-gray-500 mt-1">
                        ç”¨äºChatGPTç¿»è¯‘æœåŠ¡ï¼Œå¯†é’¥å°†å®‰å…¨å­˜å‚¨åœ¨æœ¬åœ°
                    </p>
                </div>
                

                

                
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                    <div class="flex items-start">
                        <i class="fas fa-info-circle text-gray-500 mr-2 mt-0.5"></i>
                        <div class="text-sm text-gray-800">
                            <p class="font-medium mb-1">å¦‚ä½•è·å–OpenAI APIå¯†é’¥ï¼š</p>
                            <ol class="list-decimal list-inside space-y-1 text-xs ml-2">
                                <li>è®¿é—® <a href="https://platform.openai.com/api-keys" target="_blank" class="text-blue-600 underline">OpenAI API Keys</a></li>
                                <li>ç™»å½•æ‚¨çš„OpenAIè´¦æˆ·</li>
                                <li>ç‚¹å‡»"Create new secret key"</li>
                                <li>å¤åˆ¶ç”Ÿæˆçš„å¯†é’¥ï¼ˆä»¥sk-å¼€å¤´ï¼‰</li>
                            </ol>
                        </div>
                    </div>
                </div>
                
                <div class="bg-amber-50 border border-amber-200 rounded-lg p-3">
                    <div class="flex items-start">
                        <i class="fas fa-exclamation-triangle text-amber-500 mr-2 mt-0.5"></i>
                        <div class="text-sm text-amber-800">
                            <p class="font-medium mb-1">æ³¨æ„äº‹é¡¹ï¼š</p>
                            <ul class="list-disc list-inside space-y-1 text-xs">
                                <li>ChatGPTç¿»è¯‘æœåŠ¡éœ€è¦æ¶ˆè€—APIé¢åº¦</li>
                                <li>APIå¯†é’¥ä»…å­˜å‚¨åœ¨æ‚¨çš„æµè§ˆå™¨ä¸­ï¼Œä¸ä¼šä¸Šä¼ åˆ°æœåŠ¡å™¨</li>
                                <li>è¯·å¦¥å–„ä¿ç®¡æ‚¨çš„APIå¯†é’¥ï¼Œé¿å…æ³„éœ²</li>
                                <li>å»ºè®®å®šæœŸæ£€æŸ¥APIä½¿ç”¨æƒ…å†µå’Œä½™é¢</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="flex flex-col space-y-3">
                    <div class="flex space-x-3">
                        <button id="saveApiKey" class="flex-1 bg-primary hover:bg-primary-dark text-white font-semibold py-2 px-4 rounded-lg transition-colors">
                            ä¿å­˜è®¾ç½®
                        </button>
                        <button id="resetChatGPTConfig" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors text-sm">
                            <i class="fas fa-refresh mr-1"></i>é‡ç½®é…ç½®
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- History Detail Modal -->
    <div id="historyDetailModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-2xl mx-4 max-h-[80vh] overflow-y-auto">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold text-gray-900 flex items-center">
                    <i class="fas fa-history text-purple-500 mr-2"></i>
                    ç¿»è¯‘å†å²è¯¦æƒ…
                </h3>
                <button id="closeHistoryDetailModal" class="text-gray-400 hover:text-gray-600">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <!-- æ—¶é—´æˆ³å’Œæ“ä½œ -->
                <div class="flex justify-between items-center bg-gray-50 rounded-lg p-3">
                    <div>
                        <span class="text-sm text-gray-600">ç¿»è¯‘æ—¶é—´ï¼š</span>
                        <span id="historyDetailTime" class="text-sm font-medium text-gray-900"></span>
                    </div>
                    <div class="flex space-x-2">
                        <button id="useCurrentHistory" class="px-3 py-1 bg-primary text-white text-sm rounded-lg hover:bg-primary-dark transition-colors">
                            <i class="fas fa-redo mr-1"></i>ä½¿ç”¨æ­¤ç¿»è¯‘
                        </button>
                        <button id="copyHistoryOriginal" class="px-3 py-1 bg-gray-500 text-white text-sm rounded-lg hover:bg-gray-600 transition-colors">
                            <i class="fas fa-copy mr-1"></i>å¤åˆ¶åŸæ–‡
                        </button>
                        <button id="copyHistoryTranslation" class="px-3 py-1 bg-green-500 text-white text-sm rounded-lg hover:bg-green-600 transition-colors">
                            <i class="fas fa-copy mr-1"></i>å¤åˆ¶è¯‘æ–‡
                        </button>
                    </div>
                </div>
                
                <!-- è¯­è¨€ä¿¡æ¯ -->
                <div class="flex items-center space-x-4 text-sm text-gray-600">
                    <span id="historyDetailSourceLang" class="px-2 py-1 bg-blue-100 text-blue-800 rounded"></span>
                    <i class="fas fa-arrow-right text-gray-400"></i>
                    <span id="historyDetailTargetLang" class="px-2 py-1 bg-green-100 text-green-800 rounded"></span>
                </div>
                
                <!-- åŸæ–‡ -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                        <i class="fas fa-file-text mr-1"></i>åŸæ–‡
                    </label>
                    <div id="historyDetailOriginal" class="w-full p-4 border border-gray-300 rounded-lg bg-gray-50 text-gray-900 whitespace-pre-wrap text-sm min-h-[80px] max-h-[200px] overflow-y-auto custom-scrollbar"></div>
                </div>
                
                <!-- è¯‘æ–‡ -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                        <i class="fas fa-language mr-1"></i>è¯‘æ–‡
                    </label>
                    <div id="historyDetailTranslation" class="w-full p-4 border border-gray-300 rounded-lg bg-green-50 text-gray-900 whitespace-pre-wrap text-sm min-h-[80px] max-h-[200px] overflow-y-auto custom-scrollbar"></div>
                </div>
            </div>
        </div>
    </div>



    <!-- JavaScript -->
    <script>
        // Global variables
        let currentImage = null;
        let currentImageFile = null;
        let translationHistory = [];
        let ocrWorker = null;
        let imageOcrProcessed = false; // è¿½è¸ªå½“å‰å›¾ç‰‡æ˜¯å¦å·²ç»OCRè¿‡

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            initializeDragAndDrop();
            initializePasteSupport();
            loadTranslationHistory();
            
            // åˆå§‹åŒ–OCRçŠ¶æ€æŒ‡ç¤ºå™¨
            updateOCRStatusIndicator('loading', 'å‡†å¤‡åˆå§‹åŒ–');
            
            // æ·»åŠ ç½‘ç»œçŠ¶æ€ç›‘å¬
            initializeNetworkMonitoring();
            

            
            // å»¶è¿Ÿåˆå§‹åŒ–OCRï¼Œç¡®ä¿é¡µé¢å®Œå…¨åŠ è½½
            setTimeout(() => {
                initializeOCRWorker();
            }, 1000);
        });

        // ç½‘ç»œçŠ¶æ€ç›‘æ§
        function initializeNetworkMonitoring() {
            // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ–
            window.addEventListener('online', () => {
                console.log('ç½‘ç»œè¿æ¥å·²æ¢å¤');
                showToast('ğŸ“¶ ç½‘ç»œè¿æ¥å·²æ¢å¤ï¼Œå¯ä»¥é‡è¯•OCRåˆå§‹åŒ–', 'success');
                
                // å¦‚æœOCRå¼•æ“æœªå°±ç»ªï¼Œæç¤ºç”¨æˆ·å¯ä»¥é‡è¯•
                if (!ocrWorker) {
                    setTimeout(() => {
                        showToast('ğŸ’¡ æç¤ºï¼šç°åœ¨å¯ä»¥å°è¯•é‡æ–°åˆå§‹åŒ–OCRå¼•æ“', 'info');
                    }, 2000);
                }
            });

            window.addEventListener('offline', () => {
                console.log('ç½‘ç»œè¿æ¥å·²æ–­å¼€');
                showToast('ğŸ“¶ ç½‘ç»œè¿æ¥å·²æ–­å¼€ï¼ŒOCRåŠŸèƒ½å¯èƒ½æ— æ³•æ­£å¸¸å·¥ä½œ', 'warning');
            });

            // åˆå§‹ç½‘ç»œçŠ¶æ€æ£€æŸ¥
            if (!navigator.onLine) {
                updateOCRStatusIndicator('warning', 'ç½‘ç»œç¦»çº¿');
                showToast('âš ï¸ å½“å‰ç½‘ç»œç¦»çº¿ï¼ŒOCRåŠŸèƒ½å¯èƒ½æ— æ³•åˆå§‹åŒ–', 'warning');
            }
        }

        // Initialize OCR Worker with enhanced error handling
        let ocrInitRetryCount = 0;
        const maxOcrRetries = 3;
        
        async function initializeOCRWorker() {
            try {
                // æ£€æŸ¥Tesseractæ˜¯å¦åŠ è½½
                if (typeof Tesseract === 'undefined') {
                    console.warn('Tesseract.jsæœªåŠ è½½ï¼Œç­‰å¾…åŠ è½½å®Œæˆ...');
                    
                    if (ocrInitRetryCount < maxOcrRetries) {
                        ocrInitRetryCount++;
                        showToast(`OCRç»„ä»¶åŠ è½½ä¸­... (å°è¯• ${ocrInitRetryCount}/${maxOcrRetries})`, 'warning');
                        
                        // ç­‰å¾…æ›´é•¿æ—¶é—´è®©CDNåŠ è½½å®Œæˆ
                        setTimeout(async () => {
                            await initializeOCRWorker();
                        }, 3000);
                        return;
                    } else {
                        throw new Error('Tesseract.jsåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                    }
                }

                updateOCRStatusIndicator('loading', 'æ­£åœ¨åˆå§‹åŒ–');
                console.log('å¼€å§‹åˆå§‹åŒ–OCR Worker...');
                
                // åˆ›å»ºWorkeræ—¶ä½¿ç”¨æ›´è¯¦ç»†çš„é…ç½®
                ocrWorker = await Tesseract.createWorker('eng', 1, {
                    logger: m => {
                        updateOCRProgress(m);
                        console.log('OCRåˆå§‹åŒ–è¿›åº¦:', m);
                        
                        // æ˜¾ç¤ºæ›´è¯¦ç»†çš„åˆå§‹åŒ–çŠ¶æ€
                        if (m.status === 'loading tesseract core') {
                            updateOCRStatusIndicator('loading', 'åŠ è½½æ ¸å¿ƒ');
                        } else if (m.status === 'initializing tesseract') {
                            updateOCRStatusIndicator('loading', 'åˆå§‹åŒ–å¼•æ“');
                        } else if (m.status === 'loading language traineddata') {
                            updateOCRStatusIndicator('loading', 'åŠ è½½è¯­è¨€åŒ…');
                        } else if (m.status === 'initializing api') {
                            updateOCRStatusIndicator('loading', 'åˆå§‹åŒ–API');
                        }
                    },
                    cachePath: './', // ä½¿ç”¨ç›¸å¯¹è·¯å¾„ç¼“å­˜
                    cacheMethod: 'none', // ç¦ç”¨ç¼“å­˜ä»¥é¿å…CORSé—®é¢˜
                });
                
                console.log('OCR Workeråˆå§‹åŒ–æˆåŠŸ');
                showToast('âœ… OCRå¼•æ“åˆå§‹åŒ–æˆåŠŸï¼', 'success');
                
                // é‡ç½®é‡è¯•è®¡æ•°å™¨
                ocrInitRetryCount = 0;
                
            } catch (error) {
                console.error('OCR Workeråˆå§‹åŒ–å¤±è´¥:', error);
                ocrInitRetryCount++;
                
                if (ocrInitRetryCount <= maxOcrRetries) {
                    const errorMsg = `OCRå¼•æ“åˆå§‹åŒ–å¤±è´¥ï¼Œæ­£åœ¨é‡è¯•... (${ocrInitRetryCount}/${maxOcrRetries})`;
                    showToast(errorMsg, 'warning');
                    
                    // ç­‰å¾…åé‡è¯•
                    setTimeout(async () => {
                        await initializeOCRWorker();
                    }, 5000);
                } else {
                    updateOCRStatusIndicator('error', 'åˆå§‹åŒ–å¤±è´¥');
                    showToast('âŒ OCRå¼•æ“åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ååˆ·æ–°é¡µé¢', 'error');
                    
                    // æ˜¾ç¤ºè¯Šæ–­ä¿¡æ¯
                    showOCRDiagnosticInfo(error);
                }
            }
        }

        // é‡è¯•OCRåˆå§‹åŒ–
        async function retryOCRInitialization() {
            console.log('æ‰‹åŠ¨é‡è¯•OCRåˆå§‹åŒ–...');
            
            // é‡ç½®é‡è¯•è®¡æ•°å™¨
            ocrInitRetryCount = 0;
            
            if (typeof Tesseract === 'undefined') {
                showToast('âŒ OCRç»„ä»¶æœªåŠ è½½ï¼Œæ­£åœ¨å°è¯•é‡æ–°åŠ è½½é¡µé¢ç»„ä»¶...', 'error');
                
                // å°è¯•åŠ¨æ€åŠ è½½Tesseract.js
                try {
                    await loadTesseractDynamically();
                } catch (error) {
                    showToast('âŒ æ— æ³•åŠ è½½OCRç»„ä»¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å¹¶åˆ·æ–°é¡µé¢', 'error');
                    return;
                }
            }
            
            await initializeOCRWorker();
        }

        // åŠ¨æ€åŠ è½½Tesseract.js
        async function loadTesseractDynamically() {
            return new Promise((resolve, reject) => {
                if (typeof Tesseract !== 'undefined') {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://unpkg.com/tesseract.js@5/dist/tesseract.min.js';
                script.onload = () => {
                    console.log('Tesseract.jsåŠ¨æ€åŠ è½½æˆåŠŸ');
                    showToast('OCRç»„ä»¶åŠ¨æ€åŠ è½½æˆåŠŸ', 'success');
                    resolve();
                };
                script.onerror = () => {
                    console.error('Tesseract.jsåŠ¨æ€åŠ è½½å¤±è´¥');
                    reject(new Error('åŠ¨æ€åŠ è½½å¤±è´¥'));
                };
                
                document.head.appendChild(script);
                showToast('æ­£åœ¨åŠ¨æ€åŠ è½½OCRç»„ä»¶...', 'info');
            });
        }

        // æ˜¾ç¤ºOCRè¯Šæ–­ä¿¡æ¯
        function showOCRDiagnosticInfo(error) {
            console.group('OCRè¯Šæ–­ä¿¡æ¯');
            console.log('é”™è¯¯è¯¦æƒ…:', error);
            console.log('æµè§ˆå™¨ä¿¡æ¯:', navigator.userAgent);
            console.log('Tesseractå¯ç”¨æ€§:', typeof Tesseract !== 'undefined');
            console.log('ç½‘ç»œçŠ¶æ€:', navigator.onLine ? 'åœ¨çº¿' : 'ç¦»çº¿');
            console.groupEnd();

            // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„è¯Šæ–­ä¿¡æ¯
            let diagnosticMsg = 'ğŸ” OCRè¯Šæ–­ä¿¡æ¯ï¼š\n';
            
            if (typeof Tesseract === 'undefined') {
                diagnosticMsg += 'â€¢ OCRç»„ä»¶æœªæˆåŠŸåŠ è½½\n';
                diagnosticMsg += 'â€¢ å¯èƒ½æ˜¯ç½‘ç»œè¿æ¥é—®é¢˜\n';
            } else {
                diagnosticMsg += 'â€¢ OCRç»„ä»¶å·²åŠ è½½\n';
                diagnosticMsg += 'â€¢ å¯èƒ½æ˜¯åˆå§‹åŒ–é…ç½®é—®é¢˜\n';
            }
            
            if (!navigator.onLine) {
                diagnosticMsg += 'â€¢ å½“å‰ç½‘ç»œçŠ¶æ€ï¼šç¦»çº¿\n';
            }
            
            diagnosticMsg += '\nğŸ’¡ è§£å†³å»ºè®®ï¼š\n';
            diagnosticMsg += '1. æ£€æŸ¥ç½‘ç»œè¿æ¥\n';
            diagnosticMsg += '2. åˆ·æ–°é¡µé¢é‡è¯•\n';
            diagnosticMsg += '3. å°è¯•åˆ‡æ¢ç½‘ç»œç¯å¢ƒ\n';
            diagnosticMsg += '4. ä½¿ç”¨å…¶ä»–æµè§ˆå™¨æµ‹è¯•';

            showToast(diagnosticMsg, 'warning');
        }



        // æ˜¾ç¤ºOCRå¸®åŠ©æ¨¡æ€æ¡†
        function showOCRHelpModal() {
            const helpMsg = `
                ğŸ”§ OCRå¼•æ“æ•…éšœæ’é™¤å¸®åŠ©
                
                ğŸ“‹ å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆï¼š
                
                1ï¸âƒ£ ç½‘ç»œè¿æ¥é—®é¢˜
                â€¢ æ£€æŸ¥ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸
                â€¢ å°è¯•åˆ·æ–°é¡µé¢
                â€¢ åˆ‡æ¢åˆ°å…¶ä»–ç½‘ç»œç¯å¢ƒ
                
                2ï¸âƒ£ æµè§ˆå™¨å…¼å®¹æ€§
                â€¢ å»ºè®®ä½¿ç”¨ Chromeã€Firefoxã€Edge æœ€æ–°ç‰ˆæœ¬
                â€¢ æ¸…é™¤æµè§ˆå™¨ç¼“å­˜å’ŒCookie
                â€¢ ç¦ç”¨å¹¿å‘Šæ‹¦æˆªå™¨
                
                3ï¸âƒ£ é˜²ç«å¢™/ä»£ç†é—®é¢˜
                â€¢ æ£€æŸ¥é˜²ç«å¢™è®¾ç½®
                â€¢ æš‚æ—¶å…³é—­VPN
                â€¢ æ£€æŸ¥ä¼ä¸šç½‘ç»œé™åˆ¶
                
                4ï¸âƒ£ å…¶ä»–è§£å†³æ–¹æ¡ˆ
                â€¢ å°è¯•æ— ç—•/éšç§æµè§ˆæ¨¡å¼
                â€¢ é‡å¯æµè§ˆå™¨
                â€¢ ä½¿ç”¨æ‰‹æœºçƒ­ç‚¹æµ‹è¯•
                
                ğŸ’¡ å¦‚æœé—®é¢˜æŒç»­å­˜åœ¨ï¼š
                â€¢ å¯ä»¥è·³è¿‡OCRï¼Œç›´æ¥è¾“å…¥æ–‡æœ¬è¿›è¡Œç¿»è¯‘
                â€¢ ä½¿ç”¨å…¶ä»–OCRå·¥å…·è¯†åˆ«æ–‡å­—åç²˜è´´
                â€¢ è”ç³»æŠ€æœ¯æ”¯æŒè·å–å¸®åŠ©
            `;
            
            showToast(helpMsg, 'info');
        }

        // æ›´æ–°OCRçŠ¶æ€æŒ‡ç¤ºå™¨
        function updateOCRStatusIndicator(status, message) {
            const indicator = document.getElementById('ocrStatusIndicator');
            const icon = document.getElementById('ocrStatusIcon');
            const text = document.getElementById('ocrStatusText');
            
            if (!indicator || !icon || !text) return;
            
            switch (status) {
                case 'loading':
                    icon.className = 'fas fa-spinner fa-spin text-blue-500 mr-1';
                    text.textContent = message || 'åˆå§‹åŒ–ä¸­';
                    indicator.className = 'flex items-center px-2 py-1 rounded-lg text-xs bg-blue-50 text-blue-700';
                    break;
                case 'ready':
                    icon.className = 'fas fa-check-circle text-green-500 mr-1';
                    text.textContent = message || 'å°±ç»ª';
                    indicator.className = 'flex items-center px-2 py-1 rounded-lg text-xs bg-green-50 text-green-700';
                    break;
                case 'error':
                    icon.className = 'fas fa-exclamation-circle text-red-500 mr-1';
                    text.textContent = message || 'é”™è¯¯';
                    indicator.className = 'flex items-center px-2 py-1 rounded-lg text-xs bg-red-50 text-red-700';
                    break;
                case 'warning':
                    icon.className = 'fas fa-exclamation-triangle text-yellow-500 mr-1';
                    text.textContent = message || 'è­¦å‘Š';
                    indicator.className = 'flex items-center px-2 py-1 rounded-lg text-xs bg-yellow-50 text-yellow-700';
                    break;
                default:
                    icon.className = 'fas fa-circle text-gray-500 mr-1';
                    text.textContent = message || 'æœªçŸ¥';
                    indicator.className = 'flex items-center px-2 py-1 rounded-lg text-xs bg-gray-50 text-gray-700';
            }
        }





        // Update OCR progress
        function updateOCRProgress(m) {
            const statusElement = document.getElementById('ocrStatus');
            const progressElement = document.getElementById('ocrProgress');
            
            if (m.status === 'recognizing text') {
                const progress = Math.round(m.progress * 100);
                if (progressElement) {
                    progressElement.style.width = progress + '%';
                }
                if (statusElement) {
                    statusElement.textContent = `è¯†åˆ«è¿›åº¦: ${progress}%`;
                }
            } else if (m.status) {
                if (statusElement) {
                    statusElement.textContent = getOCRStatusText(m.status);
                }
            }
        }

        // Get OCR status text in Chinese
        function getOCRStatusText(status) {
            const statusMap = {
                'initializing api': 'æ­£åœ¨åˆå§‹åŒ–API...',
                'initializing tesseract': 'æ­£åœ¨åˆå§‹åŒ–å¼•æ“...',
                'initializing scheduler': 'æ­£åœ¨åˆå§‹åŒ–è°ƒåº¦å™¨...',
                'loading language traineddata': 'æ­£åœ¨åŠ è½½è¯­è¨€åŒ…...',
                'initializing api': 'æ­£åœ¨åˆå§‹åŒ–API...',
                'recognizing text': 'æ­£åœ¨è¯†åˆ«æ–‡å­—...',
                'loading image': 'æ­£åœ¨åŠ è½½å›¾ç‰‡...',
                'preprocessing image': 'æ­£åœ¨é¢„å¤„ç†å›¾ç‰‡...',
                'recognizing text': 'æ­£åœ¨è¯†åˆ«æ–‡å­—...'
            };
            return statusMap[status] || status;
        }

        // Initialize event listeners
        function initializeEventListeners() {
            // Text input character counter
            const textInput = document.getElementById('textInput');
            const charCount = document.getElementById('charCount');
            
            textInput.addEventListener('input', function() {
                charCount.textContent = this.value.length;
            });

            // Language swap
            document.getElementById('swapLanguages').addEventListener('click', swapLanguages);

            // Clear buttons
            document.getElementById('clearTextInput').addEventListener('click', clearTextInput);
            document.getElementById('clearImageInput').addEventListener('click', clearImageInput);
            document.getElementById('clearResult').addEventListener('click', clearResult);
            document.getElementById('clearOCR').addEventListener('click', clearOCR);
            document.getElementById('clearHistory').addEventListener('click', clearHistory);

            // Copy buttons
            document.getElementById('copyResult').addEventListener('click', () => copyToClipboard('translationResult'));
            document.getElementById('copyOCR').addEventListener('click', () => copyToClipboard('ocrResult'));

            // Action buttons
            document.getElementById('translateBtn').addEventListener('click', translateText);

            // Image input
            document.getElementById('imageInput').addEventListener('change', handleImageSelect);
            document.getElementById('dropZone').addEventListener('click', () => {
                document.getElementById('imageInput').click();
            });

            // API Key setting
            document.getElementById('apiKeyBtn').addEventListener('click', openApiKeyModal);
            document.getElementById('closeApiKeyModal').addEventListener('click', closeApiKeyModal);
            document.getElementById('saveApiKey').addEventListener('click', saveApiKey);

            // Translation service change
            document.getElementById('translationService').addEventListener('change', handleTranslationServiceChange);
        }

        // Initialize drag and drop functionality
        function initializeDragAndDrop() {
            const dropZone = document.getElementById('dropZone');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            function highlight(e) {
                dropZone.classList.add('drag-over');
            }

            function unhighlight(e) {
                dropZone.classList.remove('drag-over');
            }

            dropZone.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;

                handleFiles(files);
            }
        }

        // Initialize paste support
        function initializePasteSupport() {
            document.addEventListener('paste', function(e) {
                const items = e.clipboardData.items;
                
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1) {
                        const blob = items[i].getAsFile();
                        handleImageFile(blob);
                        break;
                    }
                }
            });
        }

        // Handle file selection
        function handleFiles(files) {
            if (files.length > 0) {
                handleImageFile(files[0]);
            }
        }

        // Handle image file
        function handleImageFile(file) {
            if (!file.type.startsWith('image/')) {
                showToast('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶', 'error');
                return;
            }

            // Store both the file object and base64 data
            currentImageFile = file;
            imageOcrProcessed = false; // æ ‡è®°æ–°å›¾ç‰‡è¿˜æœªOCR

            const reader = new FileReader();
            reader.onload = function(e) {
                currentImage = e.target.result;
                displayImagePreview(currentImage);
                showToast('å›¾ç‰‡ä¸Šä¼ æˆåŠŸ', 'success');
                
                // æç¤ºç”¨æˆ·å¯ä»¥ç›´æ¥ç¿»è¯‘
                setTimeout(() => {
                    showToast('ğŸ’¡ æç¤ºï¼šæ‚¨å¯ä»¥ç›´æ¥ç‚¹å‡»"å¼€å§‹ç¿»è¯‘"æŒ‰é’®ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è¿›è¡ŒOCRè¯†åˆ«', 'info');
                }, 1000);
            };
            reader.readAsDataURL(file);
        }

        // Handle image select from input
        function handleImageSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleImageFile(file);
            }
        }

        // Display image preview
        function displayImagePreview(imageSrc) {
            const uploadPlaceholder = document.getElementById('uploadPlaceholder');
            const imagePreview = document.getElementById('imagePreview');
            const previewImage = document.getElementById('previewImage');

            uploadPlaceholder.classList.add('hidden');
            imagePreview.classList.remove('hidden');
            previewImage.src = imageSrc;
        }

        // Clear image input
        function clearImageInput() {
            currentImage = null;
            currentImageFile = null;
            imageOcrProcessed = false; // é‡ç½®OCRçŠ¶æ€
            document.getElementById('imageInput').value = '';
            document.getElementById('uploadPlaceholder').classList.remove('hidden');
            document.getElementById('imagePreview').classList.add('hidden');
            showToast('å›¾ç‰‡å·²æ¸…é™¤', 'info');
        }

        // Clear text input
        function clearTextInput() {
            document.getElementById('textInput').value = '';
            document.getElementById('charCount').textContent = '0';
            // å¦‚æœå½“å‰æœ‰å›¾ç‰‡ä¸”å·²ç»OCRè¿‡ï¼Œé‡ç½®OCRçŠ¶æ€å…è®¸é‡æ–°è¯†åˆ«
            if ((currentImage || currentImageFile) && imageOcrProcessed) {
                imageOcrProcessed = false;
                showToast('æ–‡æœ¬å·²æ¸…é™¤ï¼Œå¯é‡æ–°è¯†åˆ«å½“å‰å›¾ç‰‡', 'info');
            }
        }

        // Clear results
        function clearResult() {
            document.getElementById('translationResult').value = '';
        }

        function clearOCR() {
            document.getElementById('ocrResult').value = '';
            // å¦‚æœå½“å‰æœ‰å›¾ç‰‡ï¼Œæ ‡è®°ä¸ºæœªOCRçŠ¶æ€ï¼Œå…è®¸é‡æ–°è¯†åˆ«
            if (currentImage || currentImageFile) {
                imageOcrProcessed = false;
                showToast('OCRç»“æœå·²æ¸…é™¤ï¼Œå¯é‡æ–°è¯†åˆ«å½“å‰å›¾ç‰‡', 'info');
            }
        }

        // Swap languages
        function swapLanguages() {
            const sourceLanguage = document.getElementById('sourceLanguage');
            const targetLanguage = document.getElementById('targetLanguage');
            
            const temp = sourceLanguage.value;
            sourceLanguage.value = targetLanguage.value;
            targetLanguage.value = temp;
            
            showToast('è¯­è¨€å·²äº¤æ¢', 'info');
        }

        // Copy to clipboard
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            element.select();
            element.setSelectionRange(0, 99999);
            
            try {
                document.execCommand('copy');
                showToast('å¤åˆ¶æˆåŠŸ', 'success');
            } catch (err) {
                showToast('å¤åˆ¶å¤±è´¥', 'error');
            }
        }

        // Translation API configuration
        const TRANSLATION_CONFIG = {
            // å¯é€‰æ‹©çš„ç¿»è¯‘æœåŠ¡æä¾›å•†
            providers: {
                google: {
                    name: 'Google Translate',
                    baseUrl: 'https://translate.googleapis.com/translate_a/single',
                    free: true,
                    quality: 'good'
                },
                chatgpt: {
                    name: 'ChatGPT',
                    baseUrl: 'https://api.openai.com/v1/chat/completions',
                    free: false,
                    quality: 'excellent',
                    requiresKey: true
                }
            },
            
            // å½“å‰ä½¿ç”¨çš„æä¾›å•†
            currentProvider: 'google',
            
            // OpenAI APIé…ç½®
            openai: {
                apiKey: localStorage.getItem('openai_api_key') || '',
                model: 'gpt-3.5-turbo',
                maxTokens: 2000,
                temperature: 0.3
            },
            

            
            // è¯­è¨€ä»£ç æ˜ å°„
            languageMap: {
                'auto': 'auto',
                'zh-CN': 'zh',
                'en': 'en',
                'ja': 'ja',
                'ko': 'ko',
                'es': 'es',
                'fr': 'fr',
                'de': 'de',
                'ru': 'ru'
            },
            
            // ChatGPTè¯­è¨€æ˜ å°„ï¼ˆæ›´è¯¦ç»†çš„è¯­è¨€åç§°ï¼‰
            chatgptLanguageMap: {
                'auto': 'auto-detect',
                'zh-CN': 'Chinese (Simplified)',
                'en': 'English',
                'ja': 'Japanese',
                'ko': 'Korean',
                'es': 'Spanish',
                'fr': 'French',
                'de': 'German',
                'ru': 'Russian'
            },
            

            

        };

        // Google Translate API (å…è´¹æ¥å£)
        async function translateWithGoogle(text, sourceLang, targetLang) {
            const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${sourceLang}&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data && data[0] && data[0][0] && data[0][0][0]) {
                    return data[0].map(item => item[0]).join('');
                }
                
                throw new Error('æ— æ³•è·å–ç¿»è¯‘ç»“æœ');
            } catch (error) {
                console.error('Googleç¿»è¯‘APIé”™è¯¯:', error);
                throw error;
            }
                }

        

        // ChatGPT APIç¿»è¯‘
        async function translateWithChatGPT(text, sourceLang, targetLang) {
            const apiKey = TRANSLATION_CONFIG.openai.apiKey;
            
            if (!apiKey) {
                throw new Error('è¯·å…ˆè®¾ç½®OpenAI APIå¯†é’¥');
            }
            
            // è·å–è¯­è¨€åç§°
            const sourceLanguageName = TRANSLATION_CONFIG.chatgptLanguageMap[sourceLang] || sourceLang;
            const targetLanguageName = TRANSLATION_CONFIG.chatgptLanguageMap[targetLang] || targetLang;
            
            // æ„å»ºæç¤ºè¯
            let prompt;
            if (sourceLang === 'auto') {
                prompt = `è¯·å°†ä»¥ä¸‹æ–‡æœ¬ç¿»è¯‘æˆ${targetLanguageName}ï¼Œè¦æ±‚ç¿»è¯‘è‡ªç„¶æµç•…ã€å‡†ç¡®åœ°é“ã€‚åªè¿”å›ç¿»è¯‘ç»“æœï¼Œä¸è¦æ·»åŠ ä»»ä½•è§£é‡Šï¼š\n\n${text}`;
            } else {
                prompt = `è¯·å°†ä»¥ä¸‹${sourceLanguageName}æ–‡æœ¬ç¿»è¯‘æˆ${targetLanguageName}ï¼Œè¦æ±‚ç¿»è¯‘è‡ªç„¶æµç•…ã€å‡†ç¡®åœ°é“ã€‚åªè¿”å›ç¿»è¯‘ç»“æœï¼Œä¸è¦æ·»åŠ ä»»ä½•è§£é‡Šï¼š\n\n${text}`;
            }
            
            try {
                const response = await fetch(TRANSLATION_CONFIG.providers.chatgpt.baseUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: TRANSLATION_CONFIG.openai.model,
                        messages: [
                            {
                                role: 'system',
                                content: 'ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç¿»è¯‘åŠ©æ‰‹ï¼Œèƒ½å¤Ÿå‡†ç¡®ã€è‡ªç„¶åœ°ç¿»è¯‘å„ç§è¯­è¨€ã€‚è¯·åªè¿”å›ç¿»è¯‘ç»“æœï¼Œä¸è¦æ·»åŠ ä»»ä½•è§£é‡Šæˆ–é¢å¤–ä¿¡æ¯ã€‚'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: TRANSLATION_CONFIG.openai.maxTokens,
                        temperature: TRANSLATION_CONFIG.openai.temperature
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`OpenAI APIé”™è¯¯: ${errorData.error?.message || response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data && data.choices && data.choices[0] && data.choices[0].message) {
                    return data.choices[0].message.content.trim();
                }
                
                throw new Error('æ— æ³•è·å–ChatGPTç¿»è¯‘ç»“æœ');
            } catch (error) {
                console.error('ChatGPT APIé”™è¯¯:', error);
                throw error;
            }
        }

        // æ™ºèƒ½ç¿»è¯‘å‡½æ•°ï¼ˆå¸¦é‡è¯•æœºåˆ¶å’Œå¢å¼ºé”™è¯¯å¤„ç†ï¼‰
        async function performTranslation(text, sourceLang, targetLang) {
            // è§„èŒƒåŒ–è¯­è¨€ä»£ç 
            const normalizedSourceLang = TRANSLATION_CONFIG.languageMap[sourceLang] || sourceLang;
            const normalizedTargetLang = TRANSLATION_CONFIG.languageMap[targetLang] || targetLang;
            
            // å¦‚æœæºè¯­è¨€å’Œç›®æ ‡è¯­è¨€ç›¸åŒï¼Œç›´æ¥è¿”å›åŸæ–‡
            if (normalizedSourceLang === normalizedTargetLang) {
                return text;
            }
            
            // è·å–ç”¨æˆ·é€‰æ‹©çš„ç¿»è¯‘æœåŠ¡
            const selectedService = document.getElementById('translationService').value;
            
            // å°†ç”¨æˆ·é€‰æ‹©çš„æœåŠ¡æ”¾åœ¨æœ€å‰é¢ï¼Œå…¶ä»–æœåŠ¡ä½œä¸ºå¤‡é€‰
            const allProviders = ['google', 'chatgpt'];
            const providers = [selectedService, ...allProviders.filter(p => p !== selectedService)];
            let lastError;
            
            for (const provider of providers) {
                try {
                    let result;
                    
                    switch (provider) {
                        case 'google':
                            result = await translateWithGoogle(text, normalizedSourceLang, normalizedTargetLang);
                            break;
                        case 'chatgpt':
                            result = await translateWithChatGPT(text, normalizedSourceLang, normalizedTargetLang);
                            break;
                        default:
                            continue;
                    }
                    
                    if (result && result.trim()) {
                        // åœ¨æ§åˆ¶å°æ˜¾ç¤ºä½¿ç”¨çš„ç¿»è¯‘æœåŠ¡
                        console.log(`ç¿»è¯‘æˆåŠŸï¼Œä½¿ç”¨æœåŠ¡ï¼š${TRANSLATION_CONFIG.providers[provider].name}`);
                        
                        // å¦‚æœä¸æ˜¯ç”¨æˆ·é€‰æ‹©çš„æœåŠ¡ï¼Œæ˜¾ç¤ºæç¤º
                        if (provider !== selectedService) {
                            let switchMessage = `${TRANSLATION_CONFIG.providers[selectedService].name} ä¸å¯ç”¨ï¼Œå·²åˆ‡æ¢åˆ° ${TRANSLATION_CONFIG.providers[provider].name}`;
                            
                            // é’ˆå¯¹Claude APIæä¾›ç‰¹æ®Šè¯´æ˜
                            if (selectedService === 'claude') {
                                switchMessage += '\n\nğŸ’¡ æç¤ºï¼šClaude APIåœ¨æµè§ˆå™¨ä¸­å¯èƒ½é‡åˆ°è·¨åŸŸé™åˆ¶ï¼Œè¿™æ˜¯æ­£å¸¸ç°è±¡';
                            }
                            
                            showToast(switchMessage, 'warning');
                        }
                        
                        return result;
                    }
                } catch (error) {
                    lastError = error;
                    console.warn(`${provider} ç¿»è¯‘æœåŠ¡å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæœåŠ¡...`);
                    
                    // é’ˆå¯¹Claude APIæä¾›ç‰¹æ®Šçš„é”™è¯¯ä¿¡æ¯

                }
            }
            
            // å¦‚æœæ‰€æœ‰æœåŠ¡éƒ½å¤±è´¥ï¼ŒæŠ›å‡ºè¯¦ç»†é”™è¯¯
            let errorMessage = 'æ‰€æœ‰ç¿»è¯‘æœåŠ¡éƒ½ä¸å¯ç”¨';
            
            if (lastError) {
                if (selectedService === 'claude') {
                    errorMessage = `Claude APIæš‚æ—¶ä¸å¯ç”¨: ${lastError.message}`;
                    errorMessage += '\n\nğŸ’¡ è§£å†³å»ºè®®ï¼š\n1. æ£€æŸ¥Claude APIå¯†é’¥æ˜¯å¦æ­£ç¡®è®¾ç½®\n2. ç¡®è®¤Claudeè´¦æˆ·æœ‰è¶³å¤Ÿä½™é¢\n3. æ£€æŸ¥ç½‘ç»œè¿æ¥\n4. å°è¯•åˆ·æ–°é¡µé¢\n5. æš‚æ—¶ä½¿ç”¨Googleç¿»è¯‘æˆ–ChatGPT';
                } else {
                    errorMessage = `ç¿»è¯‘å¤±è´¥: ${lastError.message}`;
                }
            }
            
            throw new Error(errorMessage);
        }

        // ä¸»è¦ç¿»è¯‘å‡½æ•°
        async function translateText() {
            const textInput = document.getElementById('textInput').value.trim();
            const sourceLanguage = document.getElementById('sourceLanguage').value;
            const targetLanguage = document.getElementById('targetLanguage').value;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡ä¸”è¿˜æœªOCRè¿‡ - è‡ªåŠ¨æ‰§è¡ŒOCR
            if ((currentImage || currentImageFile) && !imageOcrProcessed) {
                showToast('æ£€æµ‹åˆ°æ–°å›¾ç‰‡ï¼Œæ­£åœ¨è‡ªåŠ¨è¿›è¡ŒOCRè¯†åˆ«...', 'info');
                
                try {
                    // å…ˆæ‰§è¡ŒOCRè¯†åˆ«
                    await performOCR();
                    
                    // OCRå®Œæˆåï¼Œè·å–è¯†åˆ«çš„æ–‡æœ¬
                    const recognizedText = document.getElementById('textInput').value.trim();
                    
                    if (!recognizedText) {
                        showToast('OCRè¯†åˆ«æœªè·å–åˆ°æ–‡æœ¬ï¼Œè¯·æ£€æŸ¥å›¾ç‰‡è´¨é‡', 'warning');
                        return;
                    }
                    
                    // ç»§ç»­ç¿»è¯‘æµç¨‹
                    showToast('OCRè¯†åˆ«å®Œæˆï¼Œå¼€å§‹ç¿»è¯‘...', 'info');
                    
                } catch (error) {
                    showToast('OCRè¯†åˆ«å¤±è´¥ï¼Œè¯·æ£€æŸ¥å›¾ç‰‡è´¨é‡åé‡è¯•', 'error');
                    console.error('è‡ªåŠ¨OCRé”™è¯¯:', error);
                    return;
                }
            }
            
            // è·å–è¦ç¿»è¯‘çš„æ–‡æœ¬
            const finalTextInput = document.getElementById('textInput').value.trim();
            
            if (!finalTextInput) {
                showToast('è¯·è¾“å…¥è¦ç¿»è¯‘çš„æ–‡æœ¬æˆ–ä¸Šä¼ å›¾ç‰‡', 'warning');
                return;
            }

            if (sourceLanguage === targetLanguage) {
                showToast('æºè¯­è¨€å’Œç›®æ ‡è¯­è¨€ä¸èƒ½ç›¸åŒ', 'warning');
                return;
            }

            showLoadingSpinner('loadingSpinner', true);
            
            try {
                // ä½¿ç”¨çœŸå®çš„ç¿»è¯‘API
                const translatedText = await performTranslation(finalTextInput, sourceLanguage, targetLanguage);
                
                // æ›´æ–°ç»“æœ
                document.getElementById('translationResult').value = translatedText;
                
                // æ·»åŠ åˆ°å†å²è®°å½•
                addToHistory(finalTextInput, translatedText, sourceLanguage, targetLanguage);
                
                showLoadingSpinner('loadingSpinner', false);
                showToast('ç¿»è¯‘å®Œæˆ', 'success');
                
            } catch (error) {
                showLoadingSpinner('loadingSpinner', false);
                
                // æä¾›è¯¦ç»†çš„é”™è¯¯åˆ†æ
                let errorMessage = 'ç¿»è¯‘å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•';
                let errorType = 'error';
                
                // åˆ†æé”™è¯¯ç±»å‹
                if (error.message.includes('Failed to fetch') || error.message.includes('network')) {
                    errorMessage = 'ğŸŒ ç½‘ç»œè¿æ¥é—®é¢˜\nå¯èƒ½åŸå› ï¼š\n1. ç½‘ç»œä¸ç¨³å®š\n2. é˜²ç«å¢™é˜»æ­¢\n3. éœ€è¦VPNè®¿é—®\n4. æ£€æŸ¥ç½‘ç»œè®¾ç½®';
                    errorType = 'warning';
                } else if (error.message.includes('APIé”™è¯¯')) {
                    errorMessage = 'ğŸ”§ APIè°ƒç”¨é”™è¯¯\n' + error.message + '\n\nå»ºè®®ï¼šæ£€æŸ¥APIå¯†é’¥è®¾ç½®å’Œç½‘ç»œè¿æ¥';
                } else if (error.message.includes('è¯·å…ˆè®¾ç½®OpenAI APIå¯†é’¥')) {
                    errorMessage = 'ğŸ”‘ APIå¯†é’¥æœªè®¾ç½®\nè¯·ç‚¹å‡»å¯¼èˆªæ çš„é’¥åŒ™å›¾æ ‡è®¾ç½®APIå¯†é’¥';
                    errorType = 'warning';
                } else {
                    errorMessage = `âŒ ç¿»è¯‘å¤±è´¥\né”™è¯¯è¯¦æƒ…: ${error.message}\n\nå»ºè®®ï¼šæ£€æŸ¥APIå¯†é’¥è®¾ç½®å’Œç½‘ç»œè¿æ¥`;
                }
                
                showToast(errorMessage, errorType);
                console.error('ç¿»è¯‘é”™è¯¯:', error);
                
                // å¦‚æœæ˜¯AIå¼•æ“å¤±è´¥ï¼Œæç¤ºç”¨æˆ·å¯ä»¥ä½¿ç”¨å…¶ä»–å¼•æ“
                const selectedService = document.getElementById('translationService').value;
                if (selectedService === 'chatgpt') {
                    setTimeout(() => {
                        showToast('ğŸ’¡ æç¤ºï¼šChatGPTæš‚æ—¶ä¸å¯ç”¨ï¼Œå¯ä»¥å°è¯•åˆ‡æ¢åˆ°Googleç¿»è¯‘', 'info');
                    }, 3000);
                }
            }
        }

        // Perform OCR
        async function performOCR() {
            if (!currentImage && !currentImageFile) {
                showToast('è¯·å…ˆä¸Šä¼ å›¾ç‰‡', 'warning');
                return;
            }

            // å¦‚æœå›¾ç‰‡å·²ç»è¢«OCRè¿‡ï¼Œæç¤ºç”¨æˆ·
            if (imageOcrProcessed) {
                showToast('å½“å‰å›¾ç‰‡å·²ç»è¯†åˆ«è¿‡ï¼Œå°†é‡æ–°è¿›è¡ŒOCRè¯†åˆ«...', 'info');
                imageOcrProcessed = false; // é‡ç½®çŠ¶æ€ä»¥è¿›è¡Œæ–°çš„OCR
            }

            if (!ocrWorker) {
                showToast('OCRå¼•æ“æœªå°±ç»ªï¼Œæ­£åœ¨å°è¯•é‡æ–°åˆå§‹åŒ–...', 'warning');
                
                // å°è¯•é‡æ–°åˆå§‹åŒ–
                try {
                    await retryOCRInitialization();
                    
                    // å¦‚æœåˆå§‹åŒ–æˆåŠŸï¼Œé€’å½’è°ƒç”¨è¿›è¡ŒOCR
                    if (ocrWorker) {
                        setTimeout(() => performOCR(), 1000);
                    }
                } catch (error) {
                    showToast('OCRå¼•æ“åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢', 'error');
                }
                return;
            }

            showLoadingSpinner('ocrLoadingSpinner', true);
            
            try {
                // Get selected OCR language
                const ocrLanguage = document.getElementById('ocrLanguage').value;
                
                // Preprocess image for better OCR results
                const processedImage = await preprocessImage(currentImageFile || currentImage);
                
                // Initialize OCR worker with selected language
                await ocrWorker.loadLanguage(ocrLanguage);
                await ocrWorker.initialize(ocrLanguage);
                
                // Perform OCR
                const { data: { text, confidence } } = await ocrWorker.recognize(processedImage);
                
                // Clean up the text
                const cleanedText = cleanOCRText(text);
                
                // Update UI with results
                document.getElementById('ocrResult').value = cleanedText;
                document.getElementById('textInput').value = cleanedText;
                document.getElementById('charCount').textContent = cleanedText.length;
                
                // æ ‡è®°å½“å‰å›¾ç‰‡å·²ç»OCRè¿‡
                imageOcrProcessed = true;
                
                showLoadingSpinner('ocrLoadingSpinner', false);
                
                // Show confidence score
                const confidencePercent = Math.round(confidence);
                showToast(`OCRè¯†åˆ«å®Œæˆ (ç½®ä¿¡åº¦: ${confidencePercent}%)`, 'success');
                
                // Auto-detect language if needed
                if (document.getElementById('sourceLanguage').value === 'auto') {
                    const detectedLang = detectLanguage(cleanedText);
                    if (detectedLang) {
                        document.getElementById('sourceLanguage').value = detectedLang;
                    }
                }
                
            } catch (error) {
                console.error('OCRè¯†åˆ«å¤±è´¥:', error);
                showLoadingSpinner('ocrLoadingSpinner', false);
                showToast('OCRè¯†åˆ«å¤±è´¥ï¼Œè¯·æ£€æŸ¥å›¾ç‰‡è´¨é‡æˆ–é‡è¯•', 'error');
            }
        }

        // Preprocess image for better OCR results
        async function preprocessImage(imageSource) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    // Scale image if too large
                    const maxWidth = 1920;
                    const maxHeight = 1920;
                    let { width, height } = img;
                    
                    if (width > maxWidth || height > maxHeight) {
                        const scale = Math.min(maxWidth / width, maxHeight / height);
                        width = Math.round(width * scale);
                        height = Math.round(height * scale);
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw and enhance image
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Apply image enhancements for better OCR
                    const imageData = ctx.getImageData(0, 0, width, height);
                    const data = imageData.data;
                    
                    // Increase contrast and brightness
                    for (let i = 0; i < data.length; i += 4) {
                        // Convert to grayscale for better text recognition
                        const grayscale = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        
                        // Apply threshold for better contrast
                        const threshold = 128;
                        const value = grayscale > threshold ? 255 : 0;
                        
                        data[i] = value;     // Red
                        data[i + 1] = value; // Green
                        data[i + 2] = value; // Blue
                        // Alpha channel remains unchanged
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas);
                };
                
                img.onerror = reject;
                
                if (typeof imageSource === 'string') {
                    img.src = imageSource;
                } else {
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.readAsDataURL(imageSource);
                }
            });
        }

        // Clean OCR text
        function cleanOCRText(text) {
            return text
                .replace(/\s+/g, ' ')  // Replace multiple spaces with single space
                .replace(/\n\s*\n/g, '\n')  // Remove multiple newlines
                .trim();
        }

        // Simple language detection
        function detectLanguage(text) {
            if (!text || text.length < 10) return null;
            
            // Check for Chinese characters
            if (/[\u4e00-\u9fff]/.test(text)) {
                return 'zh-CN';
            }
            
            // Check for Japanese characters
            if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) {
                return 'ja';
            }
            
            // Check for Korean characters
            if (/[\uac00-\ud7af]/.test(text)) {
                return 'ko';
            }
            
            // Check for Cyrillic (Russian)
            if (/[\u0400-\u04ff]/.test(text)) {
                return 'ru';
            }
            
            // Default to English for Latin characters
            if (/[a-zA-Z]/.test(text)) {
                return 'en';
            }
            
            return null;
        }

        // Show/hide loading spinner
        function showLoadingSpinner(spinnerId, show) {
            const spinner = document.getElementById(spinnerId);
            if (show) {
                spinner.classList.remove('hidden');
            } else {
                spinner.classList.add('hidden');
            }
        }

        // Add to translation history
        function addToHistory(originalText, translatedText, sourceLanguage, targetLanguage) {
            const historyItem = {
                id: Date.now(),
                originalText,
                translatedText,
                sourceLanguage,
                targetLanguage,
                timestamp: new Date().toLocaleString()
            };

            translationHistory.unshift(historyItem);
            
            // Keep only last 10 items
            if (translationHistory.length > 10) {
                translationHistory = translationHistory.slice(0, 10);
            }

            saveTranslationHistory();
            renderTranslationHistory();
        }

        // Render translation history
        function renderTranslationHistory() {
            const historyList = document.getElementById('historyList');
            
            if (translationHistory.length === 0) {
                historyList.innerHTML = '<div class="text-gray-500 text-sm text-center py-4">æš‚æ— ç¿»è¯‘å†å²</div>';
                return;
            }

            historyList.innerHTML = translationHistory.map(item => `
                <div class="bg-gray-50 rounded-lg p-3 text-sm cursor-pointer hover:bg-gray-100 transition-colors" onclick="showHistoryDetail(${item.id})">
                    <div class="flex justify-between items-start mb-1">
                        <span class="text-gray-600 text-xs">${item.timestamp}</span>
                        <button onclick="event.stopPropagation(); useHistoryItem(${item.id})" class="text-primary hover:text-primary-dark text-xs">
                            <i class="fas fa-redo"></i>
                        </button>
                    </div>
                    <div class="text-gray-700 mb-1">${item.originalText.substring(0, 50)}${item.originalText.length > 50 ? '...' : ''}</div>
                    <div class="text-gray-900 font-medium">${item.translatedText.substring(0, 50)}${item.translatedText.length > 50 ? '...' : ''}</div>
                    <div class="text-xs text-blue-500 mt-1">
                        <i class="fas fa-eye mr-1"></i>ç‚¹å‡»æŸ¥çœ‹å…¨æ–‡
                    </div>
                </div>
            `).join('');
        }

        // Use history item
        function useHistoryItem(id) {
            const item = translationHistory.find(h => h.id === id);
            if (item) {
                document.getElementById('textInput').value = item.originalText;
                document.getElementById('translationResult').value = item.translatedText;
                document.getElementById('charCount').textContent = item.originalText.length;
                
                // ä½¿ç”¨å†å²è®°å½•æ—¶ï¼Œå¦‚æœå½“å‰æœ‰å›¾ç‰‡ï¼Œæ ‡è®°ä¸ºå·²å¤„ç†çŠ¶æ€ï¼Œé¿å…è‡ªåŠ¨OCR
                if (currentImage || currentImageFile) {
                    imageOcrProcessed = true;
                }
                
                showToast('å†å²è®°å½•å·²åº”ç”¨', 'info');
            }
        }

        // API Key Management Functions
        function openApiKeyModal() {
            const modal = document.getElementById('apiKeyModal');
            const openaiApiKeyInput = document.getElementById('openaiApiKey');
            
            // Load existing API key
            openaiApiKeyInput.value = TRANSLATION_CONFIG.openai.apiKey;
            
            modal.classList.remove('hidden');
            
            // Focus on input
            setTimeout(() => {
                openaiApiKeyInput.focus();
            }, 100);
        }

        function closeApiKeyModal() {
            const modal = document.getElementById('apiKeyModal');
            modal.classList.add('hidden');
        }

        function saveApiKey() {
            const openaiApiKeyInput = document.getElementById('openaiApiKey');
            const openaiApiKey = openaiApiKeyInput.value.trim();
            
            let errorMessages = [];
            
            // éªŒè¯å’Œä¿å­˜OpenAI APIå¯†é’¥
            if (openaiApiKey) {
                if (!openaiApiKey.startsWith('sk-')) {
                    errorMessages.push('OpenAI APIå¯†é’¥åº”è¯¥ä»¥"sk-"å¼€å¤´');
                } else {
                    localStorage.setItem('openai_api_key', openaiApiKey);
                    TRANSLATION_CONFIG.openai.apiKey = openaiApiKey;
                }
            }
            
            if (errorMessages.length > 0) {
                showToast('âŒ ' + errorMessages.join('\n'), 'error');
                return;
            }
            
            if (!openaiApiKey) {
                showToast('è¯·è¾“å…¥OpenAI APIå¯†é’¥', 'warning');
                return;
            }
            
            closeApiKeyModal();
            showToast('âœ… APIå¯†é’¥å·²ä¿å­˜', 'success');
            
            // Update UI status
            updateAIServiceStatus();
        }



        function handleTranslationServiceChange() {
            const selectedService = document.getElementById('translationService').value;
            
            if (selectedService === 'chatgpt') {
                if (!TRANSLATION_CONFIG.openai.apiKey) {
                    showToast('ChatGPTç¿»è¯‘éœ€è¦APIå¯†é’¥ï¼Œè¯·å…ˆè®¾ç½®', 'warning');
                    openApiKeyModal();
                    return;
                }
                showToast('å·²åˆ‡æ¢åˆ°ChatGPTç¿»è¯‘å¼•æ“', 'info');
            }
            
            updateAIServiceStatus();
        }

        function updateAIServiceStatus() {
            const selectedService = document.getElementById('translationService').value;
            const apiKeyBtn = document.getElementById('apiKeyBtn');
            
            if (selectedService === 'chatgpt') {
                if (TRANSLATION_CONFIG.openai.apiKey) {
                    apiKeyBtn.classList.add('text-success');
                    apiKeyBtn.classList.remove('text-gray-500', 'text-error');
                } else {
                    apiKeyBtn.classList.add('text-error');
                    apiKeyBtn.classList.remove('text-gray-500', 'text-success');
                }
            } else {
                apiKeyBtn.classList.remove('text-success', 'text-error');
                apiKeyBtn.classList.add('text-gray-500');
            }
        }

        // Initialize AI service status on load
        document.addEventListener('DOMContentLoaded', function() {
            updateAIServiceStatus();
            
            // Add click outside modal to close
            document.getElementById('apiKeyModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeApiKeyModal();
                }
            });
            

            
            // ChatGPTé‡ç½®é…ç½®åŠŸèƒ½
            document.getElementById('resetChatGPTConfig').addEventListener('click', resetChatGPTConfig);
            
            // History detail modal events
            document.getElementById('closeHistoryDetailModal').addEventListener('click', closeHistoryDetailModal);
            document.getElementById('historyDetailModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeHistoryDetailModal();
                }
            });
            
            // History detail action buttons
            document.getElementById('useCurrentHistory').addEventListener('click', useCurrentHistoryDetail);
            document.getElementById('copyHistoryOriginal').addEventListener('click', copyHistoryOriginal);
            document.getElementById('copyHistoryTranslation').addEventListener('click', copyHistoryTranslation);
        });

        // Clear history
        function clearHistory() {
            translationHistory = [];
            saveTranslationHistory();
            renderTranslationHistory();
            showToast('å†å²è®°å½•å·²æ¸…ç©º', 'info');
        }

        // Show history detail modal
        let currentHistoryDetail = null;
        
        function showHistoryDetail(id) {
            const item = translationHistory.find(h => h.id === id);
            if (!item) return;
            
            currentHistoryDetail = item;
            
            // è¯­è¨€åç§°æ˜ å°„
            const languageNames = {
                'auto': 'è‡ªåŠ¨æ£€æµ‹',
                'zh-CN': 'ä¸­æ–‡',
                'en': 'è‹±è¯­',
                'ja': 'æ—¥è¯­',
                'ko': 'éŸ©è¯­',
                'es': 'è¥¿ç­ç‰™è¯­',
                'fr': 'æ³•è¯­',
                'de': 'å¾·è¯­',
                'ru': 'ä¿„è¯­'
            };
            
            // å¡«å……æ¨¡æ€æ¡†å†…å®¹
            document.getElementById('historyDetailTime').textContent = item.timestamp;
            document.getElementById('historyDetailSourceLang').textContent = languageNames[item.sourceLanguage] || item.sourceLanguage;
            document.getElementById('historyDetailTargetLang').textContent = languageNames[item.targetLanguage] || item.targetLanguage;
            document.getElementById('historyDetailOriginal').textContent = item.originalText;
            document.getElementById('historyDetailTranslation').textContent = item.translatedText;
            
            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            document.getElementById('historyDetailModal').classList.remove('hidden');
            
            // é˜²æ­¢é¡µé¢æ»šåŠ¨
            document.body.style.overflow = 'hidden';
        }
        
        function closeHistoryDetailModal() {
            document.getElementById('historyDetailModal').classList.add('hidden');
            document.body.style.overflow = 'auto';
            currentHistoryDetail = null;
        }
        
        function useCurrentHistoryDetail() {
            if (currentHistoryDetail) {
                document.getElementById('textInput').value = currentHistoryDetail.originalText;
                document.getElementById('translationResult').value = currentHistoryDetail.translatedText;
                document.getElementById('charCount').textContent = currentHistoryDetail.originalText.length;
                
                // è®¾ç½®è¯­è¨€é€‰æ‹©
                document.getElementById('sourceLanguage').value = currentHistoryDetail.sourceLanguage;
                document.getElementById('targetLanguage').value = currentHistoryDetail.targetLanguage;
                
                // ä½¿ç”¨å†å²è®°å½•æ—¶ï¼Œå¦‚æœå½“å‰æœ‰å›¾ç‰‡ï¼Œæ ‡è®°ä¸ºå·²å¤„ç†çŠ¶æ€ï¼Œé¿å…è‡ªåŠ¨OCR
                if (currentImage || currentImageFile) {
                    imageOcrProcessed = true;
                }
                
                closeHistoryDetailModal();
                showToast('å†å²è®°å½•å·²åº”ç”¨åˆ°ä¸»ç•Œé¢', 'success');
            }
        }
        
        function copyHistoryOriginal() {
            if (currentHistoryDetail) {
                copyTextToClipboard(currentHistoryDetail.originalText);
                showToast('åŸæ–‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
            }
        }
        
        function copyHistoryTranslation() {
            if (currentHistoryDetail) {
                copyTextToClipboard(currentHistoryDetail.translatedText);
                showToast('è¯‘æ–‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
            }
        }
        
        // Helper function to copy text to clipboard
        function copyTextToClipboard(text) {
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text);
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                document.execCommand('copy');
                textArea.remove();
            }
        }

        // Save translation history to localStorage
        function saveTranslationHistory() {
            localStorage.setItem('translationHistory', JSON.stringify(translationHistory));
        }

        // Load translation history from localStorage
        function loadTranslationHistory() {
            const saved = localStorage.getItem('translationHistory');
            if (saved) {
                translationHistory = JSON.parse(saved);
                renderTranslationHistory();
            }
        }

        // Toast notification system
        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            
            const typeClasses = {
                'success': 'bg-success text-white',
                'error': 'bg-error text-white',
                'warning': 'bg-warning text-white',
                'info': 'bg-blue-500 text-white'
            };

            const typeIcons = {
                'success': 'fas fa-check-circle',
                'error': 'fas fa-exclamation-circle',
                'warning': 'fas fa-exclamation-triangle',
                'info': 'fas fa-info-circle'
            };

            // å¤„ç†å¤šè¡Œæ¶ˆæ¯
            const formattedMessage = message.replace(/\n/g, '<br>');
            
            toast.className = `${typeClasses[type]} px-4 py-3 rounded-lg shadow-lg max-w-md transform transition-all duration-300 translate-x-full`;
            toast.innerHTML = `
                <div class="flex items-start space-x-2">
                    <i class="${typeIcons[type]} flex-shrink-0 mt-0.5"></i>
                    <div class="flex-1">
                        <div class="text-sm leading-relaxed">${formattedMessage}</div>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" class="flex-shrink-0 text-white hover:text-gray-200 ml-2">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;

            toastContainer.appendChild(toast);

            // Animate in
            setTimeout(() => {
                toast.classList.remove('translate-x-full');
            }, 100);

            // Auto remove after longer time for detailed messages
            const autoRemoveTime = message.includes('\n') ? 8000 : 3000;
            setTimeout(() => {
                toast.classList.add('translate-x-full');
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.parentElement.removeChild(toast);
                    }
                }, 300);
            }, autoRemoveTime);
        }

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + Enter for translation
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                translateText();
            }
        });

        // Show keyboard shortcuts on load
        setTimeout(() => {
            showToast('ğŸ‰ ç¿»è¯‘åŠŸèƒ½å·²ä¿®å¤ï¼ç°åœ¨æ”¯æŒçœŸå®çš„å¤šè¯­è¨€ç¿»è¯‘', 'success');
        }, 1000);
        
        setTimeout(() => {
            showToast('âœ¨ OCRåŠŸèƒ½å·²å‡çº§ï¼æ”¯æŒå¤šè¯­è¨€é«˜ç²¾åº¦è¯†åˆ«ï¼Œå¢å¼ºç¨³å®šæ€§å’Œé”™è¯¯å¤„ç†', 'success');
        }, 2500);
        
        setTimeout(() => {
            showToast('ğŸš€ æ–°åŠŸèƒ½ï¼šä¸Šä¼ å›¾ç‰‡åç›´æ¥ç‚¹å‡»ç¿»è¯‘æŒ‰é’®å³å¯è‡ªåŠ¨OCR+ç¿»è¯‘', 'success');
        }, 4000);
        
        setTimeout(() => {
            showToast('ğŸ”§ Bugä¿®å¤ï¼šç°åœ¨å¯ä»¥è¿ç»­ä¸Šä¼ å¤šå¼ å›¾ç‰‡è¿›è¡Œç¿»è¯‘ï¼Œæ— éœ€æ‰‹åŠ¨æ¸…ç©ºä¹‹å‰çš„ç»“æœ', 'success');
        }, 5500);
        
        setTimeout(() => {
            showToast('ğŸ§  æ–°å¢ChatGPTç¿»è¯‘å¼•æ“ï¼ç‚¹å‡»é’¥åŒ™å›¾æ ‡è®¾ç½®APIå¯†é’¥', 'success');
        }, 7000);
        

        
        setTimeout(() => {
            showToast('å¿«æ·é”®ï¼šCtrl+Enter å¼€å§‹ç¿»è¯‘', 'info');
        }, 13000);
        




        // ChatGPTé‡ç½®é…ç½®åŠŸèƒ½
        function resetChatGPTConfig() {
            if (confirm('ç¡®å®šè¦é‡ç½®ChatGPTé…ç½®å—ï¼Ÿè¿™å°†æ¸…é™¤å·²ä¿å­˜çš„APIå¯†é’¥å’Œç›¸å…³è®¾ç½®ã€‚')) {
                // æ¸…é™¤APIå¯†é’¥
                localStorage.removeItem('openai_api_key');
                TRANSLATION_CONFIG.openai.apiKey = '';
                
                // æ¸…é™¤è¾“å…¥æ¡†
                document.getElementById('openaiApiKey').value = '';
                
                // é‡ç½®ç¿»è¯‘æœåŠ¡é€‰æ‹©
                const serviceSelect = document.getElementById('translationService');
                if (serviceSelect.value === 'chatgpt') {
                    serviceSelect.value = 'google';
                }
                
                // æ›´æ–°UIçŠ¶æ€
                updateAIServiceStatus();
                
                showToast('âœ… ChatGPTé…ç½®å·²é‡ç½®\nå»ºè®®ï¼š\n1. é‡æ–°è¾“å…¥APIå¯†é’¥\n2. ä¿å­˜é…ç½®åå¼€å§‹ä½¿ç”¨', 'success');
            }
        }


    </script>
</body>
</html> 